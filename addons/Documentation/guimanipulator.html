<HTML>
<HEAD>
<TITLE>
ArtPaint Add-On Developer Kit: GUIManipulator
</TITLE>
</HEAD>
<BODY bgcolor="ffffff">
<DIV ALIGN=CENTER>
<IMG SRC="./images/top_bar.gif"><BR>
<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 WIDTH=500>
<TR>
<TD>
<IMG SRC="./images/transparent_dot.gif" WIDTH=100 HEIGHT=50>
</TD>
<TD COLSPAN=2>
<IMG SRC="./images/transparent_dot.gif" WIDTH=400 HEIGHT=50>
</TD>
</TR>
<TR>
<TD>
</TD>
<TD>
<H3><TT>GUIManipulator</TT>-class</H3>
Derived from: <STRONG>public Manipulator</STRONG>
<P>
Declared in: <STRONG>GUIManipulator.h</STRONG>
<P>
<HR>
<H3>Overview</H3>
The <TT>GUIManipulator</TT>-class inherits from the class <TT>Manipulator</TT>. This class is an intermediate class that declares methods that are common to <TT>StatusBarGUIManipulator</TT> and <TT>WindowGUIManipulator</TT> classes. You should never make a manipulator class that is based directly on <TT>GUIManipulator</TT>-class. Instead use the <TT>StatusBarGUIManipulator</TT> and <TT>WindowGUIManipulator</TT> classes as the base for your manipulators. 
<P>
Class <TT>GUIManipulator</TT> defines an API that is to be used by manipulators that create some kind of GUI where the user can adjust the manipulating. This GUI can be limited to allowing the user click on the image with mouse, or it can be a separate window containing multiple gizmos and gadgets. <TT>GUIManipulator</TT> API allows for quite powerful add-ons, even the tools could be made add-ons (although there would be some complications). In future the API for GUI-manipulators will be changed a little, but the changes should not be too dramatic. 
<HR>
</TD>
</TR>

<TR>
<TD>
</TD>
<TD>
<H3>Constructor and Destructor</H3>
</TD>
</TR>
<TR>
<TD>
</TD>
<TD>
<H4><A NAME="GUIManipulator()"><TT>GUIManipulator()</TT></A></H4>
<PRE>  GUIManipulator()
</PRE>
Does nothing. 
</TD>
</TR>

<TR>
<TD>
</TD>
<TD>
<HR>
<H4><A NAME="~GUIManipulator()"><TT>~GUIManipulator()</TT></A></H4>
<PRE>  virtual ~GUIManipulator()
</PRE>
Does nothing.
</TD>
</TR>

<TR>
<TD>
</TD>
<TD>
<HR>
<H3>Member Functions</H3>
</TD>
</TR>

<TR>
<TD>
<IMG SRC="./images/transparent_dot.gif" WIDTH=100 HEIGHT=20>
</TD>
</TR>

<TR>
<TD>
</TD>
<TD>
<H4><A NAME="ChangeSettings()"><TT>ChangeSettings()</TT></A></H4>
<PRE>  virtual  void*  ChangeSettings(ManipulatorSettings* 
    <I>settings</I>)
</PRE>
This function can be re-implemented in derived classes to change the settings for the manipulator. If your manipulator has settings it should store them in an instance of a class that is based on <TT>ManipulatorSettings</TT> class. This way the settings of one instance of manipulator can be stored and then later given to another instance of that same manipulator-class. You can also use this method to change the settings for the manipulator whenever the user adjust the settings with the GUI. A basic version of this method would do the following:
<PRE>  MyOwnManipulatorSettings *s;
  s = cast_as(settings,MyOwnManipulatorSettings);
  if (s != NULL)
    the_current_settings = *s;
</PRE>
Currently this function is not called from anywhere outside the manipulator's code, but this may change in the future. The default version of this function does nothing. 

</TD>
</TR>

<TR>
<TD>
</TD>
<TD>
<HR>
<H4><A NAME="Draw()"><TT>Draw()</TT></A></H4>
<PRE>  virtual  BRegion  Draw(BView* <I>target_view</I>,
    float <I>magnify_scale</I>)
</PRE>
This function can be implemented in derived classes to draw some kind of GUI on top of the image. The parameter <I>target_view</I> is the view where the drawing should be done. Because the zoom-level of the image might be something else than 1 the <I>magnify_scale</I> is provided. You can convert from the bitmap's coordinates to view's coordinates by multiplying the bitmap's coordinates with <I>magnify_scale</I>. The function should return the smallest possible region that contains the areas that this function drew to. The returned region should be in the view's coordinate space.
<P>
The following code snippet demonstrates how this function should work. Here we stroke a rectangle that surrounds bitmaps pixels (2,2) , (3,2) , (2,3) and (3,3).
<PRE>  BRect rect;
  rect.left = floor(2*mag_scale);
  rect..right = ceil((3+1)*mag_scale-1);
  rect.top = floor(2*mag_scale);
  rect.bottom = ceil((3+1)*mag_scale-1);

  target_view->StrokeRect(rect);
  
  BRegion region;
  region.Set(rect);
  rect.InsetBy(1,1);
  region.Exclude(rect);
  return region;</PRE> 
In ArtPaint at least cropping and rotation make use of this function.
</TD>
</TR>

<TR>
<TD>
</TD>
<TD>
<HR>
<H4><A NAME="ManipulateBitmap()"><TT>ManipulateBitmap()</TT></A></H4>
<PRE>  virtual  BBitmap*  ManipulateBitmap(ManipulatorSettings* 
    <I>settings</I>, BBitmap* <I>original</I>, Selection* <I>selection</I>, 
    BStatusBar* <I>status_bar</I>)
</PRE>
This is implemented by derived classes to manipulate the given bitmap. It works in the same way as the version of this function that was declared in <TT>Manipulator</TT>-class. The additional parameter <I>settings</I> determines the parameters which should be used to do the manipulation.
<P>
There are a few special cases that need to be acounted for when implementing this function. The first case is that if the <I>settings</I> indicate that no manipulation should be done the function should return NULL.
<P>
The second special case comes from the fact that manipulator might have changed the contents of some bitmap in <TT>PreviewBitmap</TT>-function. If the <I>original</I> is a pointer to the same bitmap that was last set as a preview bitmap through <TT>SetPreviewBitmap</TT>-function (or in the constructor), we should use a copy of the preview bitmap as the original instead of the <I>original</I>. The following piece of code demonstrates how to select the appropriate target and source for the manipulation.
<PRE>  BBitmap *target;
  BBitmap *source;
  if (original == preview_bitmap) {
    source = copy_of_the_preview_bitmap;
    target = original;
  }
  else {
    source = original;
    target = new BBitmap(original->Bounds(),B_RGB32,FALSE);
  }

  // Do the manipulation from source to target

  return target;
</PRE>
For more information about the preview-bitmap and its copy see the <A HREF="#SetPreviewBitmap()">SetPreviewBitmap()</A>-function.
</TD>
</TR>

<TR>
<TD>
</TD>
<TD>
<HR>
<H4><A NAME="ManipulatorCursor()"><TT>ManipulatorCursor()</TT></A></H4>
<PRE>  virtual const void* ManipulatorCursor()
</PRE>
This function should return a pointer to data that can be used to set a cursor through BApplication's SetCursor-function. The proper structure of such data is documented in the BeBook. The cursor will be changed to this whenever the add-on is in use and the cursor is on the image. An example of this function's work can be seen in rotation and translation. The default version of this function returns NULL, which indicates that the cursor is shown in its default form. 
</TD>
</TR>

<TR>
<TD>
</TD>
<TD>
<HR>
<H4><A NAME="MouseDown()"><TT>MouseDown()</TT></A></H4>
<PRE>  virtual void MouseDown(BPoint <I>point</I>, 
    uint32 <I>buttons</I>, BView* <I>target_view</I>,
    bool <I>first_click</I>)
</PRE>
This function can be implemented in derived classes to respond to mouse-events. This function should record the necessary information about the mouse-click (i.e. the <I>point</I> and perhaps <I>buttons</I> and should return as quickly as possible. This function should not poll the mouse like a normal MouseDown-function of BView is supposed to do. Instead this function will be called repeatedly while the mouse-button is held down.
<P>
The parameter <I>point</I> is in the bitmap's coordinate space and indicates the location of the cursor in the image. The parameter <I>buttons</I> indicates what mouse-buttons are held down. The parameter <I>target_view</I> can be used to get more information (e.g. what modifiers are held down). The window where <I>target_view</I> resides is already locked when this function is called. The parameter <I>first_click</I> indicates whether or not this is the first time this function is called after the mouse-button was pressed down.
<P>
The default version of this function does nothing. 
</TD>
</TR>


<TR>
<TD>
</TD>
<TD>
<HR>
<H4><A NAME="PreviewBitmap()"><TT>PreviewBitmap()</TT></A></H4>
<PRE>  virtual int32 PreviewBitmap(Selection* <I>selection</I>,
    bool <I>full_quality</I> = FALSE, BRegion* <I>updated_region</I>
    = NULL)
</PRE>
This function can be used to calculate a preview of the manipulator's effect. The preview should be calculated to the preview-bitmap that has been set through <A HREF="#SetPreviewBitmap()">SetPreviewBitmap()</A>-function. The execution of this function should be relatively fast. This allows the real-time preview of the effect when the user modifies its parameters.
<P>
The main technique for making a preview faster is making it at a lower resolution. For example if only every other pixel from every other row is calculated, the calculation will be four times as fast as calculating with full resolution. The used resolution should be decided in the <A HREF="#SetPreviewBitmap()">SetPreviewBitmap()</A>-function.
<P>
If the parameters for the effect have not changed after the last time this function was called, the resolution should be increased. This allows the user to stop changing parameters and see a more accurate preview of the effect. When the parameters change we should again return to the lower resolution. If the <I>full_quality</I> is true, then the effect should be calculated at the highest possible resolution. When calculating the image at a low resolution, it is only required to set the calculated points in the preview-bitmap. The calculated points will be automatically  copied to their neighbours to cover the whole image before displaying it.
<P>
The <I>updated_region</I> is a pointer to a region which should be set to indicate the area that the preview affects. The <I>selection</I> determines what part of the image should be affected by the preview.
<P>
This function should return the resolution that was used in calculating the preview. For example if every other pixel on every other row was calculated, the returned value should be 2. If the manipulator does not do preview, but draws a GUI, the returned value should be DRAW_ONLY_GUI. If the manipulator does not do preview and does not draw a GUI the returned value should be DRAW_NOTHING.
</TD>
</TR>

<TR>
<TD>
</TD>
<TD>
<HR>
<H4><A NAME="Reset()"><TT>Reset()</TT></A></H4>
<PRE>  virtual void Reset(Selection* <I>selection</I>)
</PRE>
This function should put the bitmap that has been used in previewing to the state that it was before any previewing. If the <I>selection</I> has been changed while previewing, it should also be returned to the state where it was before previewing started. Note that normal manipulators should not change the selection in any way. 
</TD>
</TR>

<TR>
<TD>
</TD>
<TD>
<HR>
<H4><A NAME="ReadSettings()"><TT><A HREF="#WriteSettings()">ReadSettings() see WriteSettings()</A></TT></A></H4>
</TD>
</TR>

<TR>
<TD>
</TD>
<TD>
<HR>
<H4><A NAME="ReturnHelpString()"><TT>ReturnHelpString()</TT></A></H4>
<PRE>  virtual char* ReturnHelpString()
</PRE>
This function should return a string that gives the user some information on what to do with the manipulator. The string will be displayed at the bottom of the status-bar in the paint-window.
</TD>
</TR>

<TR>
<TD>
</TD>
<TD>
<HR>
<H4><A NAME="ReturnSettings()"><TT>ReturnSettings()</TT></A></H4>
<PRE>  virtual ManipulatorSettings* ReturnSettings()
</PRE>
This function should be implemented to return a pointer to an instance of class that is subclass of <TT>ManipulatorSettings</TT>. The object that the returned pointer points to will become the property of the calling function. 
</TD>
</TR>

<TR>
<TD>
</TD>
<TD>
<HR>
<H4><A NAME="SetPreviewBitmap()"><TT>SetPreviewBitmap()</TT></A></H4>
<PRE>  virtual void SetPreviewBitmap(BBitmap* <I>bitmap</I>)
</PRE>
This function should be implemented to take note whenever the previewed bitmap changes. The <I>bitmap</I> will become the bitmap that the preview will be done to. Generally also a copy of the <I>bitmap</I> is required to allow the proper calculation of the effect and to allow <A HREF="#Reset()">Reset()</A> to work.
<P>
This function should also decide what kind of preview resolution can be used. It should decide the lower and upper limits for the resolution. The decision should be based on the size of the <I>bitmap</I> and the speed of the machines CPU. If the <A HREF="#PreviewBitmap()">PreviewBitmap()</A>-function uses multiple threads (as it usually should) you should take the number of CPUs into account when calculating the resolution. The resolutions should be something between 16x16 pixel blocks and 1x1 pixel blocks. The 16x16 pixel resolution will look quite bad unless the image is excessively big, so it should be avoided. Also the cost of padding will be effectively same with all resolutions, so lowering the resolution too much does not really help. It is always a better idea to optimize your preview calculating code and perhaps simplify some of the algorithms to obtain speed than it is to lower resolution.
</TD>
</TR>

<TR>
<TD>
</TD>
<TD>
<HR>
<H4><A NAME="WriteSettings()"><TT>WriteSettings(), ReadSettings()</TT></A></H4>
<PRE>  virtual status_t WriteSettings(BNode* <I>node</I>)

  virtual status_t ReadSettings(BNode* <I>node</I>)
</PRE>
These functions can be used to write and read the manipulators settings from the <I>node</I>. The <I>node</I> will be the file that the manipulator's add-on was loaded from. These functions should write and read the settings from the <I>node</I>'s attributes. The functions can give the <I>node</I> any attributes they wish and it is completely upon the manipulator to decide what kind of information is stored in the attributes. The returned value should indicate success by returning B_NO_ERROR. If unsuccesfull, they should return a descriptive error-code.
<P>
The default versions of these functions do nothing.  
</TD>
</TR>


<TR>
<TD>
<IMG SRC="./images/transparent_dot.gif" WITDH=100 HEIGHT=30>
</TD>
</TR>

</TABLE>
<IMG SRC="./images/bottom_bar.gif"><BR>
</DIV>

</BODY>
</HTML>
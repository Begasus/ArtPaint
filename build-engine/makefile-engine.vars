##	ZETA Generic Makefile Engine v3.0
##	Sets up variables for the targets

##	Supports Generic Makefiles versions 2.0 to 3.0

# All warnings by default
ifeq ($(WARNINGS), )
	WARNINGS := ALL
endif

# env override
ifneq ($(OPTIMIZATION),)
	OPTIMIZE := $(OPTIMIZATION)
endif

ifneq ($(C_FLAGS),)
	CFLAGS += $(C_FLAGS)
endif

# Full optimization by default
ifeq ($(OPTIMIZE), )
	OPTIMIZE	:= FULL
endif


# New type of driver target, not all kernel space code is a driver that gets a
# link.
ifeq ($(TYPE), MODULE)
	TYPE := DRIVER
	SUBTYPE := MODULE
endif


# This gets used for svg icons at the moment.
ICON_TOOL := /bin/IconTool

#   Custom overrides that can be set from the command line.
#	This allows you to have the normal makefile be a release build and
#	change it from the command line to be a debug build.
#	Use like: $ CHECK_MEM=true make
#	or		: $ BUILD_DEBUG=true make

#	For MALLOC_DEBUG=15 usage, will check every memory access for correctness.
#	NOTE: This only works in ZETA.
ifeq ($(CHECK_MEM), true)
	COMPILER_FLAGS += -fcheck-memory-usage -D_NO_INLINE_ASM=1
	BUILD_DEBUG := true
endif

ifeq ($(BUILD_DEBUG), true)
	SYMBOLS  := TRUE
	DEBUGGER := TRUE
	OPTIMIZE := NONE
	COMPILER_FLAGS += -DDEBUG=1 -fno-debug-opt
endif

ifeq ($(BUILD_PROFILE), true)
	COMPILER_FLAGS += -p
	LINKER_FLAGS += -p
endif

# Set the machine type, hardcoded until we support more than one.
CPU := x86

ifeq ($(BUILD_OUTPUT), )
	BUILD_OUTPUT	:= .
endif

#	set the directory where object files and binaries will be created
ifeq ($(OBJ_DIR), )
	ifeq ($(BUILD_OUTPUT), .)
		OBJ_DIR		:= $(BUILD_OUTPUT)/obj.$(CPU)/
	else 
		OBJ_DIR		:= $(BUILD_OUTPUT)/obj.$(CPU)/$(BOOTREL_INSTALL_DIR)/$(NAME)
	endif
endif

#	create some default settings
ifeq ($(NAME), )
	NAME := NameThisApp
endif
	
ifeq ($(TYPE), )
	TYPE := APP
endif

ifeq ($(DRIVER_PATH), )
	DRIVER_PATH := misc
endif

# 	specify that the binary should be created in the object directory by default
ifeq ($(TARGET_DIR), )
	TARGET_DIR	:= $(OBJ_DIR)
endif

#	the target goes in the TARGET_DIR
TARGET		:= $(TARGET_DIR)/$(NAME)

#	specify the mimeset tool
MIMESET		:= mimeset

#	specify the tools for adding and removing resources
XRES		:= xres

# 	platform specific settings

#	x86 Settings
ifeq ($(CPU), x86)
#	set the compiler and compiler flags
	CC		=	gcc

#	SETTING: set the CFLAGS for each binary type	
	ifeq ($(TYPE), DRIVER)
		CFLAGS	+= -D_KERNEL_MODE=1 -no-fpic
	else
		CFLAGS +=
	endif

	ifeq ($(OPTIMIZE),FULL)
		OPTIMIZER	:= -O2 -march=pentium -mcpu=pentiumpro
	else
	ifeq ($(OPTIMIZE), SOME)
		OPTIMIZER	:= -O1
	else
	ifeq ($(OPTIMIZE), NONE)
		OPTIMIZER	:= -O0
	endif
	endif
	endif
		
#	SETTING: set proper debugger flags
	ifeq ($(DEBUGGER), TRUE)
		DEBUG += -g
		OPTIMIZER = -O0
	endif
		
	CFLAGS += $(OPTIMIZER) $(DEBUG)

#	SETTING: set warning level
	ifeq ($(WARNINGS), ALL)
		CFLAGS += -W -Wall -Wno-multichar -Wno-ctor-dtor-privacy -Woverloaded-virtual -Wreturn-type -Wnon-virtual-dtor -Wshadow
	else
	ifeq ($(WARNINGS), NONE)
		CFLAGS += -w
	endif
	endif

# 	Pipe the temps by default
	ifeq ($(NO_PIPE),)
		CFLAGS += -pipe
	endif

#	set the linker and linker flags
	LD			= gcc
	LDFLAGS		+= $(DEBUG)

#	SETTING: set linker flags for each binary type
	ifeq ($(TYPE), APP)
		LDFLAGS += -Xlinker -soname=_APP_
	else
	ifeq ($(TYPE), SHARED)
		LDFLAGS += -nostart -Xlinker -soname=$(NAME)
	else
	ifeq ($(TYPE), ADDON)
		LDFLAGS += -nostart -Xlinker -soname=$(NAME)
	else
	ifeq ($(TYPE), DRIVER)
		LDFLAGS += -nostdlib /boot/develop/lib/x86/_KERNEL_
	endif 
	endif 
	endif 
	endif
endif

#	The Resource Definition application
BERES := beres


# psuedo-function for converting a list of source files in SRCS variable
# to a corresponding list of object files in $(OBJ_DIR)/xxx.o
# The "function" strips off the src file suffix (.ccp or .c or whatever)
# and then strips of the directory name, leaving just the root file name.
# It then appends the .o suffix and prepends the $(OBJ_DIR)/ path
define SRCS_LIST_TO_OBJS
	$(addprefix $(OBJ_DIR)/, $(addsuffix .o, $(foreach file, $(SRCS), \
	$(basename $(notdir $(file))))))
endef

define RDEFS_LIST_TO_RSRCS
	$(addprefix $(OBJ_DIR)/, $(addsuffix .rsrc, $(foreach file, $(RDEFS), \
	$(basename $(notdir $(file))))))
endef

ifneq ($(TYPE), DECOR)
	OBJS = $(SRCS_LIST_TO_OBJS)
	ifneq ($(RDEFS), )
		RSRCS += $(RDEFS_LIST_TO_RSRCS)
	endif
endif

# create a unique list of paths to our sourcefiles
SRC_PATHS += $(sort $(foreach file, $(SRCS), $(dir $(file))))

# add source paths to VPATH if not already present
VPATH :=
VPATH += $(addprefix :, $(subst  ,:, $(filter-out $($(subst, :, ,$(VPATH))), $(SRC_PATHS))))

#	SETTING: build the local and system include paths
ifeq ($(CPU), x86)
	LOC_INCLUDES = $(foreach path, $(SRC_PATHS) $(LOCAL_INCLUDE_PATHS), $(addprefix -I, $(path)))
	SYS_INCLUDES += -I-
	SYS_INCLUDES += $(foreach path, $(SYSTEM_INCLUDE_PATHS), $(addprefix -I, $(path)))
endif

INCLUDES = $(LOC_INCLUDES) $(SYS_INCLUDES)

# SETTING: add the -L prefix to all library paths to search
LINK_PATHS = $(foreach path, $(SRC_PATHS) $(LIBPATHS), \
	$(addprefix -L, $(path)))

#	SETTING: specify the additional libraries to link against
#	if the libraries have a .so or .a prefix, or if they are _APP_ or _KERNEL_
#	simply add them to the list
LINK_LIBS += $(filter %.so %.a _APP_ _KERNEL_, $(LIBS))
#	if the libraries do not have suffixes and are not _APP_ or _KERNEL_
#	prepend -l to each name: be becomes -lbe
LINK_LIBS += $(foreach lib, $(filter-out %.so %.a _APP_ _KERNEL_, $(LIBS)), $(addprefix -l, $(lib)))

# add to the linker flags 
LDFLAGS += $(LINK_PATHS)  $(LINK_LIBS)

#	SETTING: add the defines to the compiler flags
CFLAGS += $(foreach define, $(DEFINES), $(addprefix -D, $(define)))

#	SETTING: add the additional compiler flags
CFLAGS += $(COMPILER_FLAGS)

#	You can use this to add flags from the command line.
#	Just use the syntax $ ADDL_CLFAGS='bla bla' make
CFLAGS += $(ADDL_CFLAGS)

#	SETTING: add the additional linker flags
LDFLAGS += $(LINKER_FLAGS)

#	SETTING: use the archive tools if building a static library
#	otherwise use the linker
ifeq ($(TYPE), STATIC)
	BUILD_LINE = ar -cru "$(TARGET)" $(OBJS)
else
ifeq ($(TYPE), OBJECTS)
	# only object files, no linking
else
	BUILD_LINE = $(LD) -o "$@" $(OBJS) $(LDFLAGS)
endif
endif

#	create the resource instruction
ifeq ($(RSRCS), )
	DO_RSRCS :=
else
	DO_RSRCS := $(XRES) -o $(TARGET) $(RSRCS)
endif
		
# Install target helper
ifeq ($(INSTALL_DIR), )
	ifeq ($(TYPE), SHARED)
		INSTALL_DIR := /boot/home/config/lib
	else
		ifeq ($(TYPE), STATIC)
			INSTALL_DIR := /boot/develop/lib/$(CPU)
		else
			ifeq ($(TYPE), APP)
				INSTALL_DIR := /boot/home/config/bin
			endif
		endif
	endif
endif

# DO_LINKS is wildly different depending on vars in the makefile template. We allow
# for Driver links, Menu Links and Shared Obj links.
ifeq ($(TYPE), SHARED)
	DO_LINKS := ln -sf "$(INSTALL_DIR)/$(NAME)" "/boot/beos/etc/develop/current/lib/x86"
	TELL_LINKS := @echo Creating shared library links
else
	ifeq ($(MENU_LINKS), TRUE)
		DO_LINKS := mkdir -p "$(HOME)/config/ZetaMenu/$(APP_MENU)/"; ln -sf "$(INSTALL_DIR)/$(NAME)" "$(HOME)/config/ZetaMenu/$(APP_MENU)/"
		TELL_LINKS := @echo Creating Zeta Menu links
	else
		ifeq ($(TYPE), DRIVER)
			ifeq ($(SUBTYPE), )
				INSTALL_DIR := /boot/home/config/add-ons/kernel/drivers/bin
				USER_DEV_PATH := /boot/home/config/add-ons/kernel/drivers/dev
				DO_LINKS := mkdir -p $(USER_DEV_PATH)/$(DRIVER_PATH); ln -sf $(INSTALL_DIR)/$(NAME) $(USER_DEV_PATH)/$(DRIVER_PATH)/$(NAME)
			endif
		endif
	endif
endif

# Dependencies related junk
ifneq ($(TYPE), DECOR)
	ifeq ($(DEP_DIR), )
		DEP_DIR := $(BUILD_OUTPUT)/dep/$(BOOTREL_INSTALL_DIR)/$(NAME)
	endif
	
	# create the dep dir.
	MAKEDEP		:= $(shell mkdir -p $(DEP_DIR))

	DEPENDS		:= $(addprefix $(DEP_DIR)/,$(addsuffix .d,$(notdir $(basename $(SRCS)))))
	DEP			:= $(CC) -MM $(INCLUDES) $(CFLAGS)
	TEMPDEPFILE	= /tmp/makefile-enine_temp_deps$(NAME)$(notdir $<)
	
	DEP_MSG 	= /bin/echo generating dependencies for $<
	DEP_STAGE1	= /bin/mkdir -p "$(dir $(TEMPDEPFILE))" && /bin/echo $@ $(OBJ_DIR)/$(shell $(DEP) $<) > $(TEMPDEPFILE)
	DEP_STAGE2	= /bin/echo $(OBJ_DIR)/$(basename $(@F))".o : $(MAKEFILE)" | /bin/cat - $(TEMPDEPFILE) > $@ ; rm $(TEMPDEPFILE)
endif

ifeq ($(CHATTY), true)
	TELL_BUILDFLAGS :=
	DO_ECHO :=
	BUILD_MSG :=
	LINK_MSG :=
	RSRC_MSG :=
	MIME_MSG :=
else
ifeq ($(TYPE), OBJECTS)
	BUILD_MSG = @/bin/echo Compiling $<
	TELL_LINKFLAGS =
	LINK_MSG :=
	RSRC_MSG :=
	MIME_MSG :=
	TELL_BUILDFLAGS :=
	DO_ECHO := @
else
	BUILD_MSG = @/bin/echo Compiling $<
	TELL_LINKFLAGS = @/bin/echo; echo Link flags for $(NAME):; echo $(LDFLAGS); /bin/echo 
	LINK_MSG := @echo Linking ...
	RSRC_MSG := @echo Adding resources ...
	MIME_MSG := @echo Mimesetting ...
	TELL_BUILDFLAGS := @/bin/echo; /bin/echo Build flags for $(NAME):; echo $(INCLUDES) $(CFLAGS); echo
	DO_ECHO := @
endif
endif

# APP_VERSION

ifneq ($(APP_VERSION), )
	SETVERSION_MESSAGE := @echo Setting app version
	DO_SETVERSION := setversion $(TARGET) $(APP_VERSION)
endif

ifneq ($(SVG_ICON), )
	SVG_MESSAGE := @echo Applying SVG icon
	DO_ADD_SVG_ICON := $(ICON_TOOL) $(TARGET) Build -c 1 STD_ICON 1 -1 SVG $(SVG_ICON)
endif
	
ifeq ($(EXTRA_BUILD_MESSAGE), )
	EXTRA_BUILD_MESSAGE := @echo Performing extra build steps.
endif

#	A whole nuther ball of wax
ifeq ($(TYPE), DECOR)
	TELL_BUILDFLAGS :=
	TELL_LINKFLAGS :=
	LINK_MSG := @echo Decorizing $(NAME)
	RSRC_MSG :=
	DEP_DIR :=
	MAKEDEP :=
	DEPENDS :=
	DEP :=
	TEMPDEPFILE :=
	DEP_MSG :=
	DEP_STAGE1 :=
	DEP_STAGE2 :=
	DO_DEPENDS :=
	BUILD_LINE := decorator -q -o $(OBJ_DIR)/$(NAME) $(SRCS)
	DO_MIME = addattr -t mime "BEOS:TYPE" application/x-be-decor "$@"
	OBJS :=
else
	DO_MIME = $(MIMESET) -f "$@"
endif
